* 超越语法

之前的章节仅仅是介绍了一些基本的Perl知识，这显然是不够的．有经验的Perl程序员往往会很自如地将Perl的各种特性组合在一起，并使用一些模式和习惯用法．

好了，现在到了学习Perl的第二个阶段: 像Perl原住民（Perlish) 一样思考．这样会使你写的Perl代码更精炼，强大以及更Perlish :)

** 习惯用法(Idioms)

每一门语言，不管是编程语言或者是自然语言都有一些习惯的表达方式和用法.　例如地球在旋转，而我们却称之为日出或日落．

We brag about clever hacks and cringe at nasty hacks as we sling code.

Perl的习惯用法并不是语言的特性或者设计技巧．他们其实是一种机制和写代码的方式，这样写会让你看起来更有Perlish的腔调．

你当然可以不这样使用，但是在很多地方他们表现了Perl的强大．

*** 用$self代表对象实例

Perl 5的对象系统（Moose),把方法的调用者(invocant)当作一个默认的参数．无论你是调用一个类方法或者实例方法，@_的第一个元素总是这个方法的调用者.

习惯上，大多数Perl 5代码都使用$class来表达类方法调用者，而用$self表示实例方法的调用者．

这种习惯的强大之处在于，许多像MooseX::Method::Signatur这样的有用的扩展会假设你会使用$self作为实例方法的调用者．


*** 命名参数

列表处理是Perl执行表达式的基本组件，而Perl允许使用变长参数列表则给程序员带来了许多方便．
然而不仅仅是这样，Perl还允许程序员把参数成对的传入，换言之，Perl支持这样形式的命名参数及函数调用：

#+begin_src perl
    make_ice_cream_sundae(
	whipped_cream => 1,
	sprinkles => 1,
	bannana => 1,
	ice_cream => 'mint chocolate chip',
    );
#+end_src
让我们来看如何实现这样的支持命名参数的函数：

#+begin_src perl
    sub make_ice_cream_sundae
    {
	my %args = @_;
	my $dessert = get_ice_cream( $args{ice_cream} );
	.....
    }
#+end_src
这种技术在可以在定义import()的时候使用，这样你就可以处理按Hash的方式的处理任意多的参数了．请看：
#+begin_src perl
　　sub import
    {
	my ($class, %args) = @_;
	my $calling_package = caller();
	....
    }
#+end_src

*** Schewartizian 变换

用 Schewartizian　变换作为例子可以很好的展示Perl从Lisp那里借鉴到的对列表处理的习惯用法．

假设你有一个Perl Hash，它关系着你的合作者以及他们的电话分机号：

#+begin_src perl
	my %extensions =
	(
	    '001' => 'Armon',
	    '002' => 'Wesley',
	    '003' => 'Gerald',
	    '005' => 'Rudy',
	    '007' => 'Brandon',
	    '008' => 'Patrick',
	    '011' => 'Luke',
	    '012' => 'Lamarcus',
	    '017' => 'Chris',
	    '020' => 'Maurice',
	    '023' => 'Marcus',
	    '024' => 'Andre',
	    '052' => 'Greg',
	    '088' => 'Nic',
	);
#+end_src

先对名字按字母序排序：

#+begin_src perl
	my @sorted_names = sort values %extensions;
#+end_src	    

对于 Schewartizian变换而言，还需要维护名字及分机号的关系．

#+begin_src perl
	my @pairs = map { [ $_, $extensions{$_} ] } keys %extensions;
#+end_src

最后再把他们用名字排序

#+begin_src perl
	my @sort_pairs = sort { $a->[1] cmp $b->[1] } @pairs;
#+end_src

在sort 代码块里出现的$a和$b看上去有些奇怪，其实他们是两个包变量．它们分别代表每次从@pairs取出的相邻的两个元素.

我们可以把@short_paris转换成一个更可读的形式：

#+begin_src perl
	my @formatted_exts = map { "$_->[1], ext. $_->[0]" } @sort_pairs;
#+end_src

这样你就可以把所有的信息输出了:

#+begin_src perl
	say for @formatted_exts;
#+end_src

让我们整理一下，把所有的动作合并到一起，这样我们就可以这样来实现Schwartzian变换：

#+begin_src perl
	say for
	   map { " $_[1], ext. $_[0]" }
	   sort { $a->[1] cmp $b->[1] }
	   map { [ $_ => $extensions{$_} ]  }
	kyes %extensions;
#+end_src
    
*** 读取文件所有内容到一个标量

在使用Perl 5的全局变量的时候, local关键字至关重要．要正确的使用local关键字,你需要先理解scope的概念．
而scope有tight和lightweight之分，下面这个例子，展示了几种把一个文件的全部内容读入到一个标量的方法．

#+begin_src perl
	my $file = do { local $/ = <$fh> };

        # or

        my $file = do { local $/, <$fh> };

        # or

        my $file; { local $/, $file =  <$fh> };
#+end_src


$/ 是输入记录分隔符, 将其localizing ( local $/), 会首先将它(全局的那个$/)设置为undef（将undef作为分隔符的意思就是读入整个内容而毋须分隔）．

让我们来看第一个例子，local $/ 发生在 $/ = <$fh> 之前，于是文件内所有内容都会读入到 $/,　因为do block会整个block求值，然后返回其最后一个表达式的值，这样$/的值就被赋给$file.

第二个例子其实基本上与第一个例子相同，只是没有把文件内容赋值给$/.

第三个例子看上去繁琐了些，但是却少了第二次赋值(在读文件的时候就直接赋值给了$file)，因此它是这三个里面最高效的．


    
*** 使用Main函数

Perl无须使用特别的语法来创建闭包(closure), 你可能在不经意间就对某个词法变量创建了闭包．
许多程序常常创建很多文件级的词法变量，这样一来就可以在函数里面直接使用了，而无须把它们当作参数传进去．
但是这样会带来一个问题，随着程序变得越来越大，某个变量有可能在你使用的时候并没有初始化, 而且很难察觉到这一点．

为了避免上述问题，一个好的建议是：

　- 把你所有的主程序封装到main()
  - 不使用文件级的词法变量
　- 在你use了所有的模块或pragmas后，加入一行　exit main( @ARGV );

#+begin_src perl
	#!/usr/bin/perl
	use Modern::Perl
	....
	exit main( @ARGV );
#+end_src

在程序的一开始就调用main(),会迫使你显式地做好所有的初始化工作，以及处理好各种编译顺序．
将exit与main()结合在一起使用可以阻止其它bare code(在所有函数之外的code)被调用．
请注意,　在你实现main()的时候在成功执行的时候一定要记各返回0.

    
*** 可控的对Perl模块的执行

一个Perl模块和一个Perl程序在使用时存在明显的差异，用户可以执行Perl程序, 而只能在程序中加载Perl模块．
然而，程序和模块其实都是Perl代码, 让一个模块可以直接被执行其实很简单．同样的，让一个程序可以像一个模块被加载也不难．（这一点往往在对这个程序进行单元测试时很有用）．
你需要做的只是需要理解Perl解释器是如何执行一段代码的．

caller的一个可选参数是call frames的个数，例如caller(0)会返回当前call frame的信息．为了让一个Perl文件既可以像程序一样被执行，或者像模块一样被加载，只需要做到以下两点：

　 - 把主程序放到main()
   - 在use了所有的模块或pragmas后，加入一行:

#+begin_src perl
exit main()　unless caller(0);
#+end_src

如果是直接执行该程序（perl path/to/Module.pm) ，caller(0)会返回０，如果是在程序中加载这个模块(use Module)，则caller(0)返回１．



** 全局变量

